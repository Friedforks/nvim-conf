local ls = require("luasnip")
local s = ls.snippet
local t = ls.text_node
local i = ls.insert_node
local f = ls.function_node

ls.add_snippets("cpp", {
  s("intmain", {
    f(function()
      local date = os.date("%Y-%m-%d")
      -- local user = os.getenv("USER") or os.getenv("USERNAME") or "Unknown"
      local user = "Chixiyu"
      return {
        "/*",
        " * Created by: " .. user,
        " * Date: " .. date,
        " */",
        "",
      }
    end),
    t({
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "typedef long long ll;",
      "",
      "int main() {",
      "    ios::sync_with_stdio(false);",
      "    cin.tie(nullptr);",
      "    ",
    }),
    i(1),
    t({
      "",
      "    return 0;",
      "}",
    }),
  }),

  s("cases", {
    t("\\begin{cases}"),
    i(1),
    t("\\end{cases}"),
  }),

  -- Fenwick Tree snippet
  s("fenwick", {
    t({
      "/**",
      " * Fenwick Tree (Binary Indexed Tree) implementation",
      " * @template T - Type of elements (typically int or long long)",
      " * Supports point updates and range sum queries in O(log n) time",
      " */",
      "template <typename T>",
      "class FenwickTree {",
      "private:",
      "    vector<T> c;  // Internal array for BIT",
      "    int n;        // Size of the tree",
      "",
      "    /**",
      "     * Calculates the lowest set bit in x",
      "     * @param x: int - Input number",
      "     * @return: int - Value of lowest set bit",
      "     * Time Complexity: O(1)",
      "     */",
      "    int lowbit(int x) {",
      "        return x & -x;",
      "    }",
      "",
      "public:",
      "    /**",
      "     * Constructor: initializes the Fenwick Tree",
      "     * @param size: int - Size of the array (1-based indexing)",
      "     * Time Complexity: O(n)",
      "     * Space Complexity: O(n)",
      "     */",
      "    FenwickTree(int size) {",
      "        n = size;",
      "        c.resize(n + 1, 0);",
      "    }",
      "",
      "    /**",
      "     * Point update operation",
      "     * @param x: int - Position to update (1-based indexing)",
      "     * @param k: T - Value to add",
      "     * Time Complexity: O(log n)",
      "     */",
      "    void update(int x, T k) {",
      "        for (int i = x; i <= n; i += lowbit(i)) {",
      "            c[i] += k;",
      "        }",
      "    }",
      "",
      "    /**",
      "     * Prefix sum query [1, x]",
      "     * @param x: int - Right boundary of query (1-based indexing)",
      "     * @return: T - Sum of elements from index 1 to x",
      "     * Time Complexity: O(log n)",
      "     */",
      "    T query(int x) {",
      "        T sum = 0;",
      "        for (int i = x; i > 0; i -= lowbit(i)) {",
      "            sum += c[i];",
      "        }",
      "        return sum;",
      "    }",
      "",
      "    /**",
      "     * Range sum query [l, r]",
      "     * @param l: int - Left boundary (1-based indexing)",
      "     * @param r: int - Right boundary (1-based indexing)",
      "     * @return: T - Sum of elements from index l to r",
      "     * Time Complexity: O(log n)",
      "     */",
      "    T rangeQuery(int l, int r) {",
      "        return query(r) - query(l - 1);",
      "    }",
      "",
      "    /**",
      "     * Builds Fenwick Tree from input array",
      "     * @param a: const vector<T>& - Input array (0-based indexing)",
      "     * Time Complexity: O(n log n)",
      "     */",
      "    void build(const vector<T>& a) {",
      "        for (int i = 1; i <= n; ++i) {",
      "            update(i, a[i - 1]);",
      "        }",
      "    }",
      "};",
    }),
  }),

  -- segment tree
  s("segtree_sum", {
    t({
      "template <typename T>",
      "class SegTree_Sum {",
      "private:",
      "    vector<T> tree, lazy;",
      "    int n;",
      "    ",
      "    /**",
      "     * Pushes lazy propagation value from parent node to children nodes",
      "     * @param node: int - Current node index in segment tree",
      "     * @param left: int - Left boundary of current segment",
      "     * @param right: int - Right boundary of current segment",
      "     * Time Complexity: O(1)",
      "     */",
      "    void push_down(int node, int left, int right) {",
      "        if (lazy[node] == 0) return;",
      "        tree[node] += (right - left + 1) * lazy[node];",
      "        if (left < right) {",
      "            lazy[node * 2] += lazy[node];",
      "            lazy[node * 2 + 1] += lazy[node];",
      "        }",
      "        lazy[node] = 0;",
      "    }",
      "    ",
      "    /**",
      "     * Builds segment tree from input array",
      "     * @param arr: vector<T>& - Input array",
      "     * @param node: int - Current node index in segment tree",
      "     * @param left: int - Left boundary of current segment",
      "     * @param right: int - Right boundary of current segment",
      "     * Time Complexity: O(n), where n is the size of input array",
      "     */",
      "    void build(const vector<T>& arr, int node, int left, int right) {",
      "        if (left == right) {",
      "            tree[node] = arr[left];",
      "            return;",
      "        }",
      "        int mid = left + (right - left) / 2;",
      "        build(arr, node * 2, left, mid);",
      "        build(arr, node * 2 + 1, mid + 1, right);",
      "        tree[node] = tree[node * 2] + tree[node * 2 + 1];",
      "    }",
      "    ",
      "    /**",
      "     * Updates range [l, r] by adding value",
      "     * @param l: int - Left boundary of update range",
      "     * @param r: int - Right boundary of update range",
      "     * @param value: T - Value to add",
      "     * @param node: int - Current node index",
      "     * @param left: int - Left boundary of current segment",
      "     * @param right: int - Right boundary of current segment",
      "     * Time Complexity: O(log n)",
      "     */",
      "    void update_range(int l, int r, T value, int node, int left, int right) {",
      "        push_down(node, left, right);",
      "        if (left > r || right < l) return;",
      "        if (left >= l && right <= r) {",
      "            lazy[node] += value;",
      "            push_down(node, left, right);",
      "            return;",
      "        }",
      "        int mid = left + (right - left) / 2;",
      "        update_range(l, r, value, node * 2, left, mid);",
      "        update_range(l, r, value, node * 2 + 1, mid + 1, right);",
      "        tree[node] = tree[node * 2] + tree[node * 2 + 1];",
      "    }",
      "    ",
      "    /**",
      "     * Queries sum of range [l, r]",
      "     * @param l: int - Left boundary of query range",
      "     * @param r: int - Right boundary of query range",
      "     * @param node: int - Current node index",
      "     * @param left: int - Left boundary of current segment",
      "     * @param right: int - Right boundary of current segment",
      "     * @return: T - Sum of elements in range [l, r]",
      "     * Time Complexity: O(log n)",
      "     */",
      "    T query_range(int l, int r, int node, int left, int right) {",
      "        if (left > r || right < l) return 0;",
      "        push_down(node, left, right);",
      "        if (left >= l && right <= r) return tree[node];",
      "        int mid = left + (right - left) / 2;",
      "        return query_range(l, r, node * 2, left, mid) +",
      "               query_range(l, r, node * 2 + 1, mid + 1, right);",
      "    }",
      "    ",
      "public:",
      "    /**",
      "     * Constructor for Segment Tree",
      "     * @param arr: vector<T>& - Input array",
      "     * Time Complexity: O(n), where n is the size of input array",
      "     * Space Complexity: O(n) for tree and lazy arrays",
      "     */",
      "    SegTree_Sum(const vector<T>& arr) {",
      "        n = arr.size();",
      "        tree.resize(4 * n);",
      "        lazy.resize(4 * n);",
      "        build(arr, 1, 0, n - 1);",
      "    }",
      "    ",
      "    // Range update: adds value to all elements in range [l, r]",
      "    void update(int l, int r, T value) {",
      "        update_range(l, r, value, 1, 0, n - 1);",
      "    }",
      "    ",
      "    // Range query: returns sum of elements in range [l, r]",
      "    T query(int l, int r) {",
      "        return query_range(l, r, 1, 0, n - 1);",
      "    }",
      "};",
    }),
  }),

  -- segtree minimum
  s("segtree_min", {
    t({
      "template <typename T>",
      "class SegTree_Min {",
      "private:",
      "    vector<T> tree, lazy;",
      "    int n;",
      "    const T INF = numeric_limits<T>::max();",
      "    ",
      "    /**",
      "     * Pushes lazy propagation value from parent node to children nodes",
      "     * Used for range updates with lazy propagation",
      "     * @param node: int - Current node index in segment tree",
      "     * @param left: int - Left boundary of current segment",
      "     * @param right: int - Right boundary of current segment",
      "     * Time Complexity: O(1)",
      "     */",
      "    void push_down(int node, int left, int right) {",
      "        if (lazy[node] == 0) return;",
      "        tree[node] += lazy[node];",
      "        if (left < right) {",
      "            lazy[node * 2] += lazy[node];",
      "            lazy[node * 2 + 1] += lazy[node];",
      "        }",
      "        lazy[node] = 0;",
      "    }",
      "    ",
      "    /**",
      "     * Builds segment tree from input array",
      "     * Recursively builds tree bottom-up for minimum queries",
      "     * @param arr: vector<T>& - Input array",
      "     * @param node: int - Current node index in segment tree",
      "     * @param left: int - Left boundary of current segment",
      "     * @param right: int - Right boundary of current segment",
      "     * Time Complexity: O(n), where n is the size of input array",
      "     */",
      "    void build(const vector<T>& arr, int node, int left, int right) {",
      "        if (left == right) {",
      "            tree[node] = arr[left];",
      "            return;",
      "        }",
      "        int mid = left + (right - left) / 2;",
      "        build(arr, node * 2, left, mid);",
      "        build(arr, node * 2 + 1, mid + 1, right);",
      "        tree[node] = min(tree[node * 2], tree[node * 2 + 1]);",
      "    }",
      "    ",
      "    /**",
      "     * Updates range [l, r] by adding value",
      "     * Supports lazy propagation for efficient range updates",
      "     * @param l: int - Left boundary of update range",
      "     * @param r: int - Right boundary of update range",
      "     * @param value: T - Value to add",
      "     * @param node: int - Current node index",
      "     * @param left: int - Left boundary of current segment",
      "     * @param right: int - Right boundary of current segment",
      "     * Time Complexity: O(log n)",
      "     */",
      "    void update_range(int l, int r, T value, int node, int left, int right) {",
      "        push_down(node, left, right);",
      "        if (left > r || right < l) return;",
      "        if (left >= l && right <= r) {",
      "            lazy[node] += value;",
      "            push_down(node, left, right);",
      "            return;",
      "        }",
      "        int mid = left + (right - left) / 2;",
      "        update_range(l, r, value, node * 2, left, mid);",
      "        update_range(l, r, value, node * 2 + 1, mid + 1, right);",
      "        tree[node] = min(tree[node * 2], tree[node * 2 + 1]);",
      "    }",
      "    ",
      "    /**",
      "     * Queries minimum of range [l, r]",
      "     * Returns minimum element in the specified range",
      "     * @param l: int - Left boundary of query range",
      "     * @param r: int - Right boundary of query range",
      "     * @param node: int - Current node index",
      "     * @param left: int - Left boundary of current segment",
      "     * @param right: int - Right boundary of current segment",
      "     * @return: T - Minimum element in range [l, r]",
      "     * Time Complexity: O(log n)",
      "     */",
      "    T query_range(int l, int r, int node, int left, int right) {",
      "        if (left > r || right < l) return INF;",
      "        push_down(node, left, right);",
      "        if (left >= l && right <= r) return tree[node];",
      "        int mid = left + (right - left) / 2;",
      "        return min(query_range(l, r, node * 2, left, mid),",
      "                  query_range(l, r, node * 2 + 1, mid + 1, right));",
      "    }",
      "    ",
      "public:",
      "    /**",
      "     * Constructor for Segment Tree (Minimum)",
      "     * Initializes tree with given array for range minimum queries",
      "     * @param arr: vector<T>& - Input array",
      "     * Time Complexity: O(n), where n is the size of input array",
      "     * Space Complexity: O(n) for tree and lazy arrays",
      "     */",
      "    SegTree_Min(const vector<T>& arr) {",
      "        n = arr.size();",
      "        tree.resize(4 * n);",
      "        lazy.resize(4 * n);",
      "        build(arr, 1, 0, n - 1);",
      "    }",
      "    ",
      "    /**",
      "     * Public method for range update",
      "     * @param l: int - Left boundary (inclusive)",
      "     * @param r: int - Right boundary (inclusive)",
      "     * @param value: T - Value to add to range",
      "     */",
      "    void update(int l, int r, T value) {",
      "        update_range(l, r, value, 1, 0, n - 1);",
      "    }",
      "    ",
      "    /**",
      "     * Public method for range minimum query",
      "     * @param l: int - Left boundary (inclusive)",
      "     * @param r: int - Right boundary (inclusive)",
      "     * @return: T - Minimum value in range [l, r]",
      "     */",
      "    T query(int l, int r) {",
      "        return query_range(l, r, 1, 0, n - 1);",
      "    }",
      "};",
      "",
      "// Usage example:",
      "// vector<int> arr = {1, 3, 2, 7, 9, 11};",
      "// SegTree_Min<int> st(arr);",
      "// st.query(1, 4);  // Returns minimum in range [1,4]",
      "// st.update(1, 3, 2);  // Adds 2 to all elements in range [1,3]",
    }),
  }),

  -- segtree maximum
  s("segtree_max", {
    t({
      "template <typename T>",
      "class SegTree_Max {",
      "private:",
      "    vector<T> tree, lazy;",
      "    int n;",
      "    const T INF = numeric_limits<T>::lowest();  // For maximum queries",
      "    ",
      "    /**",
      "     * Pushes lazy propagation value from parent to children",
      "     * Handles delayed updates for range operations",
      "     * @param node: Current node index",
      "     * @param left: Left boundary of current segment",
      "     * @param right: Right boundary of current segment",
      "     * Time: O(1)",
      "     */",
      "    void push_down(int node, int left, int right) {",
      "        if (lazy[node] == 0) return;",
      "        tree[node] += lazy[node];",
      "        if (left < right) {",
      "            lazy[node * 2] += lazy[node];",
      "            lazy[node * 2 + 1] += lazy[node];",
      "        }",
      "        lazy[node] = 0;",
      "    }",
      "    ",
      "    /**",
      "     * Builds the segment tree from input array",
      "     * Creates a tree where each node stores maximum of its range",
      "     * @param arr: Input array",
      "     * @param node: Current node index",
      "     * @param left: Left boundary",
      "     * @param right: Right boundary",
      "     * Time: O(n)",
      "     */",
      "    void build(const vector<T>& arr, int node, int left, int right) {",
      "        if (left == right) {",
      "            tree[node] = arr[left];",
      "            return;",
      "        }",
      "        int mid = left + (right - left) / 2;",
      "        build(arr, node * 2, left, mid);",
      "        build(arr, node * 2 + 1, mid + 1, right);",
      "        tree[node] = max(tree[node * 2], tree[node * 2 + 1]);",
      "    }",
      "    ",
      "    /**",
      "     * Updates a range by adding a value",
      "     * Uses lazy propagation for efficient range updates",
      "     * @param l: Left boundary of update range",
      "     * @param r: Right boundary of update range",
      "     * @param value: Value to add",
      "     * @param node: Current node",
      "     * @param left: Current segment left boundary",
      "     * @param right: Current segment right boundary",
      "     * Time: O(log n)",
      "     */",
      "    void update_range(int l, int r, T value, int node, int left, int right) {",
      "        push_down(node, left, right);",
      "        if (left > r || right < l) return;",
      "        if (left >= l && right <= r) {",
      "            lazy[node] += value;",
      "            push_down(node, left, right);",
      "            return;",
      "        }",
      "        int mid = left + (right - left) / 2;",
      "        update_range(l, r, value, node * 2, left, mid);",
      "        update_range(l, r, value, node * 2 + 1, mid + 1, right);",
      "        tree[node] = max(tree[node * 2], tree[node * 2 + 1]);",
      "    }",
      "    ",
      "    /**",
      "     * Queries maximum value in a range",
      "     * Returns maximum element in specified range [l,r]",
      "     * @param l: Left query boundary",
      "     * @param r: Right query boundary",
      "     * @param node: Current node",
      "     * @param left: Current segment left boundary",
      "     * @param right: Current segment right boundary",
      "     * @return: Maximum value in range [l,r]",
      "     * Time: O(log n)",
      "     */",
      "    T query_range(int l, int r, int node, int left, int right) {",
      "        if (left > r || right < l) return INF;",
      "        push_down(node, left, right);",
      "        if (left >= l && right <= r) return tree[node];",
      "        int mid = left + (right - left) / 2;",
      "        return max(query_range(l, r, node * 2, left, mid),",
      "                  query_range(l, r, node * 2 + 1, mid + 1, right));",
      "    }",
      "    ",
      "    /**",
      "     * Finds leftmost index where value exceeds threshold",
      "     * Binary searches for first position satisfying condition",
      "     * @param threshold: Value to exceed",
      "     * @param node: Current node",
      "     * @param left: Left boundary",
      "     * @param right: Right boundary",
      "     * @return: Leftmost index or -1 if not found",
      "     * Time: O(log n)",
      "     */",
      "    int find_first_above(T threshold, int node, int left, int right) {",
      "        push_down(node, left, right);",
      "        if (tree[node] <= threshold) return -1;",
      "        if (left == right) return left;",
      "        ",
      "        int mid = left + (right - left) / 2;",
      "        push_down(node * 2, left, mid);",
      "        int res = find_first_above(threshold, node * 2, left, mid);",
      "        if (res != -1) return res;",
      "        return find_first_above(threshold, node * 2 + 1, mid + 1, right);",
      "    }",
      "    ",
      "public:",
      "    /**",
      "     * Constructor: Initializes segment tree for maximum queries",
      "     * @param arr: Input array",
      "     * Time: O(n) for construction",
      "     * Space: O(n) for tree storage",
      "     */",
      "    SegTree_Max(const vector<T>& arr) {",
      "        n = arr.size();",
      "        tree.resize(4 * n);",
      "        lazy.resize(4 * n);",
      "        build(arr, 1, 0, n - 1);",
      "    }",
      "    ",
      "    /**",
      "     * Updates range [l,r] by adding value",
      "     * @param l: Left boundary (inclusive)",
      "     * @param r: Right boundary (inclusive)",
      "     * @param value: Value to add",
      "     */",
      "    void update(int l, int r, T value) {",
      "        update_range(l, r, value, 1, 0, n - 1);",
      "    }",
      "    ",
      "    /**",
      "     * Queries maximum in range [l,r]",
      "     * @param l: Left boundary (inclusive)",
      "     * @param r: Right boundary (inclusive)",
      "     * @return: Maximum value in range",
      "     */",
      "    T query(int l, int r) {",
      "        return query_range(l, r, 1, 0, n - 1);",
      "    }",
      "    ",
      "    /**",
      "     * Finds first position where value > threshold",
      "     * @param threshold: Value to exceed",
      "     * @return: Leftmost index or -1 if not found",
      "     */",
      "    int find_first_above(T threshold) {",
      "        return find_first_above(threshold, 1, 0, n - 1);",
      "    }",
      "    ",
      "    /**",
      "     * Gets maximum value in entire range",
      "     * @return: Maximum value in tree",
      "     */",
      "    T get_max() {",
      "        return tree[1];",
      "    }",
      "};",
      "",
      "// Usage example:",
      "// vector<int> arr = {1, 3, 2, 7, 9, 11};",
      "// SegTree_Max<int> st(arr);",
      "// int max_val = st.query(1, 4);  // Maximum in range [1,4]",
      "// st.update(1, 3, 2);  // Add 2 to all elements in range [1,3]",
      "// int first_above_5 = st.find_first_above(5);  // First position > 5",
    }),
  }),

  -- DSU with path compression
  s("dsu", {
    t({
      "/**",
      " * Disjoint Set Union (DSU) with path compression and union by rank",
      " * @template T - Type of elements (typically int)",
      " * Supports find and union operations in nearly O(1) amortized time",
      " */",
      "template <typename T>",
      "class DSU {",
      "private:",
      "    vector<T> parent;  // Stores the parent of each element",
      "    vector<T> rank;    // Stores the rank (height) of each set",
      "",
      "public:",
      "    /**",
      "     * Constructor: initializes DSU with n elements",
      "     * @param n: T - Number of elements",
      "     * Time Complexity: O(n)",
      "     * Space Complexity: O(n)",
      "     */",
      "    DSU(T n) {",
      "        parent.resize(n);",
      "        rank.resize(n, 1);",
      "        for (T i = 0; i < n; ++i) {",
      "            parent[i] = i;",
      "        }",
      "    }",
      "",
      "    /**",
      "     * Finds the representative of the set containing x",
      "     * @param x: T - Element to find",
      "     * @return: T - Representative of x's set",
      "     * Time Complexity: O(α(n)) ≈ O(1) amortized",
      "     */",
      "    T find(T x) {",
      "        if (parent[x] != x) {",
      "            parent[x] = find(parent[x]);",
      "        }",
      "        return parent[x];",
      "    }",
      "",
      "    /**",
      "     * Unites the sets containing elements x and y",
      "     * @param x: T - First element",
      "     * @param y: T - Second element",
      "     * @return: bool - True if x and y were in different sets",
      "     * Time Complexity: O(α(n)) ≈ O(1) amortized",
      "     */",
      "    bool unite(T x, T y) {",
      "        T rootX = find(x);",
      "        T rootY = find(y);",
      "",
      "        if (rootX == rootY) return false;",
      "",
      "        if (rank[rootX] < rank[rootY]) {",
      "            parent[rootX] = rootY;",
      "        } else if (rank[rootX] > rank[rootY]) {",
      "            parent[rootY] = rootX;",
      "        } else {",
      "            parent[rootY] = rootX;",
      "            rank[rootX] += 1;",
      "        }",
      "",
      "        return true;",
      "    }",
      "",
      "    /**",
      "     * Checks if two elements are in the same set",
      "     * @param x: T - First element",
      "     * @param y: T - Second element",
      "     * @return: bool - True if x and y are in the same set",
      "     * Time Complexity: O(α(n)) ≈ O(1) amortized",
      "     */",
      "    bool isSameSet(T x, T y) {",
      "        return find(x) == find(y);",
      "    }",
      "};",
    }),
  }),

  -- dfs
  s("dfs", {
    t({
      "/**",
      " * Depth-First Search (DFS) implementations",
      " * Both recursive and iterative versions",
      " */",
      "",
      "vector<vector<int>> adj;  // Adjacency list",
      "int n;  // Number of vertices",
      "",
      "/**",
      " * Recursive DFS",
      " * @param u: int - Current vertex",
      " * @param visited: vector<bool>& - Visited vertices tracker",
      " * Time Complexity: O(V + E)",
      " * Space Complexity: O(V) for recursion stack",
      " */",
      "void dfs(int u, vector<bool>& visited) {",
      "    visited[u] = true;",
      "    // Process vertex u here",
      "    ",
      "    for (int v : adj[u]) {",
      "        if (!visited[v]) {",
      "            dfs(v, visited);",
      "        }",
      "    }",
      "    // Post-process vertex u here (if needed)",
      "}",
      "",
      "/**",
      " * Iterative DFS using stack",
      " * @param start: int - Starting vertex",
      " * Time Complexity: O(V + E)",
      " * Space Complexity: O(V)",
      " */",
      "void dfs_iterative(int start) {",
      "    vector<bool> visited(n, false);",
      "    stack<int> s;",
      "    s.push(start);",
      "    ",
      "    while (!s.empty()) {",
      "        int u = s.top();",
      "        s.pop();",
      "        ",
      "        if (visited[u]) continue;",
      "        visited[u] = true;",
      "        // Process vertex u here",
      "        ",
      "        // Push neighbors in reverse order to match recursive DFS",
      "        for (int i = adj[u].size() - 1; i >= 0; --i) {",
      "            int v = adj[u][i];",
      "            if (!visited[v]) {",
      "                s.push(v);",
      "            }",
      "        }",
      "    }",
      "}",
    }),
  }),

  -- BFS
  s("bfs", {
    t({
      "/**",
      " * Breadth-First Search (BFS) implementations",
      " * Includes standard BFS and multi-source BFS",
      " */",
      "",
      "vector<vector<int>> adj;  // Adjacency list",
      "int n;  // Number of vertices",
      "",
      "/**",
      " * Standard BFS",
      " * @param start: int - Starting vertex",
      " * @return: vector<int> - Distance array from start",
      " * Time Complexity: O(V + E)",
      " * Space Complexity: O(V)",
      " */",
      "vector<int> bfs(int start) {",
      "    vector<bool> visited(n, false);",
      "    vector<int> dist(n, -1);  // Distance array",
      "    queue<int> q;",
      "    ",
      "    visited[start] = true;",
      "    dist[start] = 0;",
      "    q.push(start);",
      "    ",
      "    while (!q.empty()) {",
      "        int u = q.front();",
      "        q.pop();",
      "        // Process vertex u here",
      "        ",
      "        for (int v : adj[u]) {",
      "            if (!visited[v]) {",
      "                visited[v] = true;",
      "                dist[v] = dist[u] + 1;",
      "                q.push(v);",
      "            }",
      "        }",
      "    }",
      "    ",
      "    return dist;",
      "}",
      "",
      "/**",
      " * Multi-source BFS",
      " * @param starts: const vector<int>& - Starting vertices",
      " * @return: vector<int> - Distance array from nearest source",
      " * Time Complexity: O(V + E)",
      " * Space Complexity: O(V)",
      " */",
      "vector<int> multi_bfs(const vector<int>& starts) {",
      "    vector<bool> visited(n, false);",
      "    vector<int> dist(n, -1);",
      "    queue<int> q;",
      "    ",
      "    for (int start : starts) {",
      "        visited[start] = true;",
      "        dist[start] = 0;",
      "        q.push(start);",
      "    }",
      "    ",
      "    while (!q.empty()) {",
      "        int u = q.front();",
      "        q.pop();",
      "        ",
      "        for (int v : adj[u]) {",
      "            if (!visited[v]) {",
      "                visited[v] = true;",
      "                dist[v] = dist[u] + 1;",
      "                q.push(v);",
      "            }",
      "        }",
      "    }",
      "    ",
      "    return dist;",
      "}",
    }),
  }),

  --
  s("sparse_table", {
    t({
      "/**",
      " * Sparse Table for Range Minimum/Maximum Query (RMQ)",
      " * @template T - Type of array elements",
      " * @template F - Binary function type for the operation (e.g., min, max, gcd)",
      " * ",
      " * Time Complexity:",
      " *   - Build: O(n log n)",
      " *   - Query: O(1)",
      " * Space Complexity: O(n log n)",
      " * ",
      " * Usage:",
      " *   // For Range Minimum Query (RMQ)",
      " *   vector<int> arr = {2, 5, 1, 4, 9, 3};",
      " *   auto min_op = [](int a, int b) { return min(a, b); };",
      " *   SparseTable<int, decltype(min_op)> st(arr, min_op);",
      " *   int min_val = st.query(1, 4);  // Minimum value in range [1,4]",
      " *   ",
      " *   // For Range Maximum Query",
      " *   auto max_op = [](int a, int b) { return max(a, b); };",
      " *   SparseTable<int, decltype(max_op)> st_max(arr, max_op);",
      " *   ",
      " *   // For Range GCD Query",
      " *   auto gcd_op = [](int a, int b) { return __gcd(a, b); };",
      " *   SparseTable<int, decltype(gcd_op)> st_gcd(arr, gcd_op);",
      " * ",
      " * Note: Only works for idempotent operations (like min, max, gcd)",
      " *       Does not support point updates",
      " */",
      "template<typename T, typename F>",
      "class SparseTable {",
      "private:",
      "    vector<vector<T>> st;  // Sparse table",
      "    F f;                   // Binary function (e.g., min, max)",
      "    vector<int> log;       // Log table for optimization",
      "    int n;                 // Array size",
      "",
      "public:",
      "    /**",
      "     * Constructor: builds sparse table from input array",
      "     * @param arr: const vector<T>& - Input array",
      "     * @param func: F - Binary function for range queries",
      "     */",
      "    SparseTable(const vector<T>& arr, F func) : f(func) {",
      "        n = arr.size();",
      "        log.resize(n + 1);",
      "        ",
      "        // Precompute logs",
      "        log[1] = 0;",
      "        for (int i = 2; i <= n; i++) {",
      "            log[i] = log[i/2] + 1;",
      "        }",
      "        ",
      "        // Build sparse table",
      "        int max_log = log[n] + 1;",
      "        st.resize(n, vector<T>(max_log));",
      "        ",
      "        // Initialize with original array",
      "        for (int i = 0; i < n; i++) {",
      "            st[i][0] = arr[i];",
      "        }",
      "        ",
      "        // Fill sparse table",
      "        for (int j = 1; j < max_log; j++) {",
      "            for (int i = 0; i + (1 << j) <= n; i++) {",
      "                st[i][j] = f(st[i][j-1],",
      "                            st[i + (1 << (j-1))][j-1]);",
      "            }",
      "        }",
      "    }",
      "",
      "    /**",
      "     * Query range [l, r] (inclusive)",
      "     * @param l: int - Left boundary (0-based indexing)",
      "     * @param r: int - Right boundary (0-based indexing)",
      "     * @return: T - Result of the query",
      "     * Precondition: 0 <= l <= r < n",
      "     */",
      "    T query(int l, int r) {",
      "        int j = log[r - l + 1];",
      "        return f(st[l][j], st[r - (1 << j) + 1][j]);",
      "    }",
      "    ",
      "    /**",
      "     * Returns size of the array",
      "     * @return: int - Size of array",
      "     */",
      "    int size() const {",
      "        return n;",
      "    }",
      "};",
      "",
      "// Common operations for ST Table",
      "struct RMQ_Operations {",
      "    // Minimum query",
      "    template<typename T>",
      "    static T min(T a, T b) { return std::min(a, b); }",
      "    ",
      "    // Maximum query",
      "    template<typename T>",
      "    static T max(T a, T b) { return std::max(a, b); }",
      "    ",
      "    // GCD query",
      "    static int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }",
      "};",
      "",
      "/**",
      " * Example usage with predefined operations:",
      " * ",
      " * // For RMQ (Range Minimum Query)",
      " * vector<int> arr = {2, 5, 1, 4, 9, 3};",
      " * SparseTable<int, decltype(&RMQ_Operations::min<int>)> st_min(arr, RMQ_Operations::min);",
      " * int min_val = st_min.query(1, 4);",
      " * ",
      " * // For Range GCD Query",
      " * SparseTable<int, decltype(&RMQ_Operations::gcd)> st_gcd(arr, RMQ_Operations::gcd);",
      " * int gcd_val = st_gcd.query(2, 5);",
      " */",
    }),
  }),

  -- binary_search
  s("binary_search", {
    t({
      "/**",
      " * Binary Search Template Collection",
      " * Includes common variants of binary search",
      " * ",
      " * Time Complexity: O(log n) for all variants",
      " * Space Complexity: O(1)",
      " * ",
      " * Usage:",
      " *   // Find exact value",
      " *   vector<int> arr = {1, 3, 5, 7, 9};",
      " *   int pos = binary_search(arr, 5);  // returns 2",
      " * ",
      " *   // Find lower bound",
      " *   int lower = lower_bound(arr, 6);  // returns 3 (position of 7)",
      " * ",
      " *   // Find upper bound",
      " *   int upper = upper_bound(arr, 5);  // returns 3 (position of 7)",
      " */",
      "",
      "/**",
      " * Standard binary search to find exact value",
      " * @param arr: const vector<T>& - Sorted array",
      " * @param target: T - Target value to find",
      " * @return: int - Index of target, or -1 if not found",
      " */",
      "template<typename T>",
      "int binary_search(const vector<T>& arr, const T& target) {",
      "    int left = 0, right = arr.size() - 1;",
      "    ",
      "    while (left <= right) {",
      "        int mid = left + (right - left) / 2;",
      "        ",
      "        if (arr[mid] == target) return mid;",
      "        if (arr[mid] < target) left = mid + 1;",
      "        else right = mid - 1;",
      "    }",
      "    ",
      "    return -1;  // Not found",
      "}",
      "",
      "/**",
      " * Lower bound - first element >= target",
      " * @param arr: const vector<T>& - Sorted array",
      " * @param target: T - Target value",
      " * @return: int - Index of first element >= target, or arr.size() if not found",
      " */",
      "template<typename T>",
      "int lower_bound(const vector<T>& arr, const T& target) {",
      "    int left = 0, right = arr.size();",
      "    ",
      "    while (left < right) {",
      "        int mid = left + (right - left) / 2;",
      "        ",
      "        if (arr[mid] < target) left = mid + 1;",
      "        else right = mid;",
      "    }",
      "    ",
      "    return left;",
      "}",
      "",
      "/**",
      " * Upper bound - first element > target",
      " * @param arr: const vector<T>& - Sorted array",
      " * @param target: T - Target value",
      " * @return: int - Index of first element > target, or arr.size() if not found",
      " */",
      "template<typename T>",
      "int upper_bound(const vector<T>& arr, const T& target) {",
      "    int left = 0, right = arr.size();",
      "    ",
      "    while (left < right) {",
      "        int mid = left + (right - left) / 2;",
      "        ",
      "        if (arr[mid] <= target) left = mid + 1;",
      "        else right = mid;",
      "    }",
      "    ",
      "    return left;",
      "}",
      "",
      "/**",
      " * Binary search on real numbers within epsilon precision",
      " * @param func: F - Function to evaluate",
      " * @param left: double - Left boundary",
      " * @param right: double - Right boundary",
      " * @param eps: double - Precision (default: 1e-9)",
      " * @return: double - Value that minimizes/maximizes func",
      " */",
      "template<typename F>",
      "double binary_search_real(F func, double left, double right, double eps = 1e-9) {",
      "    while (right - left > eps) {",
      "        double mid = left + (right - left) / 2;",
      "        ",
      "        if (func(mid)) left = mid;",
      "        else right = mid;",
      "    }",
      "    ",
      "    return left;",
      "}",
      "",
      "/**",
      " * Binary search with predicate function",
      " * @param left: int - Left boundary",
      " * @param right: int - Right boundary",
      " * @param pred: F - Predicate function returning bool",
      " * @return: int - First value where predicate becomes true",
      " */",
      "template<typename F>",
      "int binary_search_pred(int left, int right, F pred) {",
      "    while (left < right) {",
      "        int mid = left + (right - left) / 2;",
      "        ",
      "        if (pred(mid)) right = mid;",
      "        else left = mid + 1;",
      "    }",
      "    ",
      "    return left;",
      "}",
      "",
      "/**",
      " * Example usage:",
      " * ",
      " * // Basic binary search",
      " * vector<int> arr = {1, 3, 5, 7, 9};",
      " * int pos1 = binary_search(arr, 5);        // Returns 2",
      " * int pos2 = lower_bound(arr, 6);         // Returns 3",
      " * int pos3 = upper_bound(arr, 5);         // Returns 3",
      " * ",
      " * // Binary search on real numbers",
      " * auto square = [](double x) { return x * x <= 2; };",
      " * double sqrt2 = binary_search_real(square, 0, 2);",
      " * ",
      " * // Binary search with predicate",
      " * auto is_good = [&](int x) { return x * x >= 100; };",
      " * int result = binary_search_pred(0, 100, is_good);  // Returns 10",
      " */",
    }),
  }),

  -- Kruskal (depend on DSU)
  s("kruskal", {
    t({
      "/**",
      " * Edge structure for weighted undirected graph",
      " * @template T - Type of vertex indices and weights",
      " */",
      "template <typename T>",
      "struct Edge {",
      "    T u;      // Start vertex",
      "    T v;      // End vertex",
      "    T weight; // Weight of the edge",
      "",
      "    bool operator<(const Edge& other) const {",
      "        return weight < other.weight;",
      "    }",
      "};",
      "",
      "/**",
      " * Kruskal's algorithm for finding Minimum Spanning Tree",
      " * @template T - Type of vertex indices and weights",
      " * @param V: T - Number of vertices",
      " * @param edges: vector<Edge<T>>& - List of all edges",
      " * @param mst: vector<Edge<T>>& - Output vector to store MST edges",
      " * @return: T - Total weight of the MST",
      " * Time Complexity: O(E log E) where E is the number of edges",
      " * Space Complexity: O(V) for DSU and O(E) for storing edges",
      " */",
      "template <typename T>",
      "T kruskal(T V, vector<Edge<T>>& edges, vector<Edge<T>>& mst) {",
      "    sort(edges.begin(), edges.end());",
      "    DSU<T> dsu(V);",
      "",
      "    T totalWeight = 0;",
      "    for (const Edge<T>& edge : edges) {",
      "        if (dsu.unite(edge.u, edge.v)) {",
      "            mst.push_back(edge);",
      "            totalWeight += edge.weight;",
      "        }",
      "    }",
      "",
      "    return totalWeight;",
      "}",
    }),
  }),

  -- Prim
  s("prim", {
    t({
      "/**",
      " * Edge structure for weighted undirected graph",
      " * @template T - Type of weights (typically int or double)",
      " */",
      "template <typename T>",
      "struct Edge {",
      "    T to;      // Target vertex",
      "    T weight;  // Edge weight",
      "",
      "    bool operator>(const Edge& other) const {",
      "        return weight > other.weight;",
      "    }",
      "};",
      "",
      "/**",
      " * Prim's algorithm for finding Minimum Spanning Tree",
      " * @template T - Type of weights",
      " * @param graph: vector<vector<Edge<T>>>& - Adjacency list representation",
      " * @param mst: vector<Edge<T>>& - Output vector to store MST edges",
      " * @return: T - Total weight of the MST",
      " * Time Complexity: O((V + E) log V) where V is vertices and E is edges",
      " * Space Complexity: O(V + E) for graph and O(V) for visited array",
      " * Note: Assumes graph is connected and undirected",
      " */",
      "template <typename T>",
      "T prim(vector<vector<Edge<T>>>& graph, vector<Edge<T>>& mst) {",
      "    int V = graph.size();",
      "    vector<bool> visited(V, false);",
      "    priority_queue<Edge<T>, vector<Edge<T>>, greater<Edge<T>>> pq;",
      "    ",
      "    T totalWeight = 0;",
      "    visited[0] = true;",
      "    ",
      "    for (const Edge<T>& e : graph[0]) {",
      "        pq.push(e);",
      "    }",
      "    ",
      "    while (!pq.empty() && mst.size() < V - 1) {",
      "        Edge<T> curr = pq.top();",
      "        pq.pop();",
      "        ",
      "        if (visited[curr.to]) continue;",
      "        ",
      "        mst.push_back(curr);",
      "        totalWeight += curr.weight;",
      "        visited[curr.to] = true;",
      "        ",
      "        for (const Edge<T>& e : graph[curr.to]) {",
      "            if (!visited[e.to]) {",
      "                pq.push(e);",
      "            }",
      "        }",
      "    }",
      "    ",
      "    return totalWeight;",
      "}",
    }),
  }),

  -- (special case CCC24S4) MST with dfs
  s("dfs_mst", {
    t({
      "/**",
      " * DFS-based Minimum Spanning Tree (Prim's algorithm with DFS)",
      " * Time Complexity: O(E log V)",
      " * Space Complexity: O(V + E)",
      " * ",
      " * Usage:",
      " *   DFSMST mst(n);  // n vertices (0-based)",
      " *   mst.add_edge(u, v, weight);",
      " *   auto [total_weight, tree_edges] = mst.build_mst(0);  // start from vertex 0",
      " */",
      "class DFSMST {",
      "private:",
      "    struct Edge {",
      "        int to;",
      "        long long weight;",
      "        int id;  // Original edge ID",
      "",
      "        Edge(int t, long long w, int i) : to(t), weight(w), id(i) {}",
      "        ",
      "        bool operator>(const Edge& other) const {",
      "            return weight > other.weight;",
      "        }",
      "    };",
      "",
      "    int n, edge_count;",
      "    vector<vector<Edge>> adj;",
      "    vector<bool> visited;",
      "    vector<pair<int, int>> tree_edges;  // Stores edges in MST",
      "    vector<Edge> original_edges;         // Stores all edges for reconstruction",
      "    long long total_weight;",
      "",
      "    /**",
      "     * DFS implementation of Prim's algorithm",
      "     * @param v: Current vertex",
      "     * @param pq: Priority queue for edge selection",
      "     */",
      "    void dfs_prim(int v, priority_queue<Edge, vector<Edge>, greater<Edge>>& pq) {",
      "        visited[v] = true;",
      "",
      "        // Add all edges from current vertex to priority queue",
      "        for (const Edge& e : adj[v]) {",
      "            if (!visited[e.to]) {",
      "                pq.push(e);",
      "            }",
      "        }",
      "",
      "        // Process edges in order of increasing weight",
      "        while (!pq.empty()) {",
      "            Edge e = pq.top();",
      "            pq.pop();",
      "",
      "            if (!visited[e.to]) {",
      "                // Add edge to MST",
      "                tree_edges.push_back({original_edges[e.id].to, e.to});",
      "                total_weight += e.weight;",
      "                ",
      "                // Continue DFS from new vertex",
      "                dfs_prim(e.to, pq);",
      "            }",
      "        }",
      "    }",
      "",
      "public:",
      "    DFSMST(int vertices) : n(vertices), edge_count(0) {",
      "        adj.resize(n);",
      "        visited.resize(n);",
      "        total_weight = 0;",
      "    }",
      "",
      "    /**",
      "     * Adds undirected edge to the graph",
      "     * @param u, v: Vertices to connect",
      "     * @param weight: Edge weight",
      "     */",
      "    void add_edge(int u, int v, long long weight) {",
      "        adj[u].push_back(Edge(v, weight, edge_count));",
      "        adj[v].push_back(Edge(u, weight, edge_count));",
      "        original_edges.push_back(Edge(u, weight, edge_count));",
      "        edge_count++;",
      "    }",
      "",
      "    /**",
      "     * Builds minimum spanning tree starting from given vertex",
      "     * @param start: Starting vertex",
      "     * @return: pair{total_weight, vector of edges in MST}",
      "     */",
      "    pair<long long, vector<pair<int, int>>> build_mst(int start = 0) {",
      "        visited.assign(n, false);",
      "        tree_edges.clear();",
      "        total_weight = 0;",
      "",
      "        priority_queue<Edge, vector<Edge>, greater<Edge>> pq;",
      "        dfs_prim(start, pq);",
      "",
      "        // Check if MST covers all vertices",
      "        for (bool v : visited) {",
      "            if (!v) return {-1, {}};  // Graph is not connected",
      "        }",
      "",
      "        return {total_weight, tree_edges};",
      "    }",
      "",
      "    /**",
      "     * Checks if graph is connected",
      "     * @return: bool - True if graph is connected",
      "     */",
      "    bool is_connected() {",
      "        visited.assign(n, false);",
      "        dfs_check_connected(0);",
      "        return count(visited.begin(), visited.end(), true) == n;",
      "    }",
      "",
      "private:",
      "    void dfs_check_connected(int v) {",
      "        visited[v] = true;",
      "        for (const Edge& e : adj[v]) {",
      "            if (!visited[e.to]) {",
      "                dfs_check_connected(e.to);",
      "            }",
      "        }",
      "    }",
      "",
      "public:",
      "    /**",
      "     * Verifies if current tree_edges form a valid MST",
      "     * @return: bool - True if current solution is valid MST",
      "     */",
      "    bool verify_mst() {",
      "        if (tree_edges.size() != n - 1) return false;",
      "",
      "        // Check connectivity",
      "        vector<vector<int>> tree_adj(n);",
      "        for (auto [u, v] : tree_edges) {",
      "            tree_adj[u].push_back(v);",
      "            tree_adj[v].push_back(u);",
      "        }",
      "",
      "        visited.assign(n, false);",
      "        int count = 0;",
      "        function<void(int)> dfs = [&](int v) {",
      "            count++;",
      "            visited[v] = true;",
      "            for (int u : tree_adj[v]) {",
      "                if (!visited[u]) dfs(u);",
      "            }",
      "        };",
      "        dfs(0);",
      "",
      "        return count == n;",
      "    }",
      "",
      "    /**",
      "     * Gets edges adjacent to vertex v in the MST",
      "     * @param v: Vertex to check",
      "     * @return: vector of adjacent edges in MST",
      "     */",
      "    vector<pair<int, long long>> get_mst_adjacent(int v) {",
      "        vector<pair<int, long long>> result;",
      "        for (auto [u, w] : tree_edges) {",
      "            if (u == v) result.push_back({w, original_edges[w].weight});",
      "            if (w == v) result.push_back({u, original_edges[u].weight});",
      "        }",
      "        return result;",
      "    }",
      "};",
      "",
      "/**",
      " * Example usage:",
      " * ",
      " * DFSMST mst(4);  // Graph with 4 vertices",
      " * mst.add_edge(0, 1, 2);",
      " * mst.add_edge(1, 2, 3);",
      " * mst.add_edge(2, 3, 1);",
      " * mst.add_edge(3, 0, 4);",
      " * ",
      " * auto [weight, edges] = mst.build_mst(0);",
      " * if (weight == -1) {",
      ' *     cout << "Graph is not connected\\n";',
      " * } else {",
      ' *     cout << "MST weight: " << weight << "\\n";',
      " *     for (auto [u, v] : edges) {",
      ' *         cout << u << " - " << v << "\\n";',
      " *     }",
      " * }",
      " */",
    }),
  }),

  -- Floyd
  s("floyd", {
    t({
      "/**",
      " * Floyd-Warshall Algorithm for All-Pairs Shortest Paths",
      " * @template T - Type of weights (typically int or long long)",
      " * @param dist: vector<vector<T>>& - Adjacency matrix of the graph",
      " *        Initially dist[i][j] is the weight of edge i->j, or INF if no edge exists",
      " *        Self-loops dist[i][i] should be 0",
      " * @param V: int - Number of vertices",
      " * Time Complexity: O(V³)",
      " * Space Complexity: O(V²)",
      " * Note: Can handle negative edges but not negative cycles",
      " */",
      "template <typename T>",
      "void floyd(vector<vector<T>>& dist, int V) {",
      "    for (int k = 0; k < V; ++k)",
      "        for (int i = 0; i < V; ++i)",
      "            for (int j = 0; j < V; ++j)",
      "                if (dist[i][k] != INF && dist[k][j] != INF)",
      "                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);",
      "}",
    }),
  }),

  -- Topological sort

  s("toposort", {
    t({
      "/**",
      " * Topological Sort Implementation",
      " * Includes both DFS and Kahn's algorithm",
      " * Time Complexity: O(V + E) for both methods",
      " * Space Complexity: O(V)",
      " * ",
      " * Usage:",
      " *   TopoSort ts(n);  // n vertices (0-based)",
      " *   ts.add_edge(u, v);  // add directed edge u->v",
      " *   auto order = ts.kahn();  // or ts.dfs()",
      ' *   if (order.empty()) cout << "Graph has cycle";',
      " */ ",
      "class TopoSort {",
      "private:",
      "    int n;",
      "    vector<vector<int>> adj;",
      "    vector<int> in_degree;",
      "",
      "    // DFS implementation helper",
      "    bool dfs_visit(int v, vector<int>& order, vector<int>& color) {",
      "        color[v] = 1;  // Gray: vertex is being processed",
      "",
      "        for (int u : adj[v]) {",
      "            if (color[u] == 1) return false;  // Found cycle",
      "            if (color[u] == 0 && !dfs_visit(u, order, color)) {",
      "                return false;",
      "            }",
      "        }",
      "",
      "        color[v] = 2;  // Black: vertex is done",
      "        order.push_back(v);",
      "        return true;",
      "    }",
      "",
      "public:",
      "    TopoSort(int vertices) : n(vertices) {",
      "        adj.resize(n);",
      "        in_degree.resize(n, 0);",
      "    }",
      "",
      "    void add_edge(int from, int to) {",
      "        adj[from].push_back(to);",
      "        in_degree[to]++;",
      "    }",
      "",
      "    /**",
      "     * DFS-based topological sort",
      "     * @return vector<int> - Topological order (reversed), empty if cycle exists",
      "     * Advantage: Can detect cycles during sort",
      "     */",
      "    vector<int> dfs() {",
      "        vector<int> order;",
      "        vector<int> color(n, 0);  // 0:white, 1:gray, 2:black",
      "",
      "        for (int v = 0; v < n; v++) {",
      "            if (color[v] == 0) {",
      "                if (!dfs_visit(v, order, color)) {",
      "                    return {};  // Graph has cycle",
      "                }",
      "            }",
      "        }",
      "",
      "        reverse(order.begin(), order.end());",
      "        return order;",
      "    }",
      "",
      "    /**",
      "     * Kahn's algorithm (BFS-based)",
      "     * @return vector<int> - Topological order, empty if cycle exists",
      "     * Advantage: Generates order in non-decreasing distances",
      "     */",
      "    vector<int> kahn() {",
      "        vector<int> order;",
      "        queue<int> q;",
      "",
      "        // Find all vertices with in-degree 0",
      "        for (int v = 0; v < n; v++) {",
      "            if (in_degree[v] == 0) {",
      "                q.push(v);",
      "            }",
      "        }",
      "",
      "        while (!q.empty()) {",
      "            int v = q.front();",
      "            q.pop();",
      "            order.push_back(v);",
      "",
      "            for (int u : adj[v]) {",
      "                in_degree[u]--;",
      "                if (in_degree[u] == 0) {",
      "                    q.push(u);",
      "                }",
      "            }",
      "        }",
      "",
      "        // Check if all vertices are included",
      "        if (order.size() != n) {",
      "            return {};  // Graph has cycle",
      "        }",
      "        return order;",
      "    }",
      "",
      "    /**",
      "     * Checks if graph has a cycle",
      "     * @return bool - True if cycle exists",
      "     */",
      "    bool has_cycle() {",
      "        return kahn().empty();",
      "    }",
      "",
      "    /**",
      "     * Gets possible number of different topological sorts",
      "     * @return long long - Number of possible orderings",
      "     * Note: Only works for small graphs (factorial complexity)",
      "     */",
      "    long long count_possible_orders() {",
      "        vector<int> base_order = kahn();",
      "        if (base_order.empty()) return 0;",
      "",
      "        // Create graph of dependencies",
      "        vector<vector<bool>> depends(n, vector<bool>(n, false));",
      "        for (int v = 0; v < n; v++) {",
      "            for (int u : adj[v]) {",
      "                depends[v][u] = true;",
      "            }",
      "        }",
      "",
      "        long long count = 0;",
      "        vector<int> perm = base_order;",
      "        do {",
      "            bool valid = true;",
      "            // Check if permutation respects dependencies",
      "            for (int i = 0; i < n && valid; i++) {",
      "                for (int j = i + 1; j < n && valid; j++) {",
      "                    if (depends[perm[j]][perm[i]]) {",
      "                        valid = false;",
      "                    }",
      "                }",
      "            }",
      "            if (valid) count++;",
      "        } while (next_permutation(perm.begin(), perm.end()));",
      "",
      "        return count;",
      "    }",
      "};",
      "",
      "/**",
      " * Example usage:",
      " * ",
      " * TopoSort ts(6);  // 6 vertices (0-based)",
      " * ts.add_edge(5, 2);",
      " * ts.add_edge(5, 0);",
      " * ts.add_edge(4, 0);",
      " * ts.add_edge(4, 1);",
      " * ts.add_edge(2, 3);",
      " * ts.add_edge(3, 1);",
      " * ",
      " * // Using Kahn's algorithm",
      " * vector<int> order1 = ts.kahn();",
      " * if (order1.empty()) {",
      ' *     cout << "Graph has cycle\\n";',
      " * } else {",
      ' *     for (int v : order1) cout << v << " ";  // e.g., 4 5 0 2 3 1',
      " * }",
      " * ",
      " * // Using DFS",
      " * vector<int> order2 = ts.dfs();",
      " * // order2 might be different but still valid, e.g., 5 4 2 3 1 0",
      " */",
    }),
  }),

  -- Dijkstra
  s("dijkstra", {
    t({
      "/**",
      " * Edge structure for weighted graph",
      " * @template T - Type of edge weight (typically int or double)",
      " */",
      "template <typename T>",
      "struct Edge {",
      "    int to;     // Target vertex",
      "    T weight;   // Edge weight",
      "};",
      "",
      "/**",
      " * Finds shortest paths from start vertex to all other vertices using Dijkstra's algorithm",
      " * @template T - Type of edge weight (typically int or double)",
      " * @param graph: vector<vector<Edge<T>>> - Adjacency list where graph[u] contains edges from vertex u",
      " * @param start: int - The source vertex (0-based indexing)",
      " * @return: vector<T> - Array of shortest distances from start to each vertex",
      " *                     distances[i] = shortest distance from start to vertex i",
      " *                     distances[i] = numeric_limits<T>::max() if vertex i is unreachable",
      " * Time Complexity: O(E log V) where E is number of edges and V is number of vertices",
      " * Space Complexity: O(V) for distances array and priority queue",
      " * Note: Requires non-negative edge weights for correctness",
      " * Usage Example:",
      " *     vector<vector<Edge<int>>> graph(n);",
      " *     graph[0].push_back({1, 5});  // edge from 0 to 1 with weight 5",
      " *     vector<int> dist = dijkstra(graph, 0);",
      " */",
      "template <typename T>",
      "vector<T> dijkstra(const vector<vector<Edge<T>>>& graph, int start) {",
      "    int V = graph.size();  // Number of vertices",
      "    ",
      "    // Initialize distances to infinity",
      "    vector<T> dist(V, numeric_limits<T>::max());",
      "    dist[start] = 0;",
      "    ",
      "    // Priority queue to store {distance, vertex}",
      "    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> pq;",
      "    pq.push({0, start});",
      "    ",
      "    // Track visited vertices",
      "    vector<bool> visited(V, false);",
      "    ",
      "    while (!pq.empty()) {",
      "        auto [d, curr] = pq.top();",
      "        pq.pop();",
      "        ",
      "        // Skip if vertex is already visited",
      "        if (visited[curr]) continue;",
      "        visited[curr] = true;",
      "        ",
      "        // Explore all adjacent vertices",
      "        for (const Edge<T>& e : graph[curr]) {",
      "            if (!visited[e.to] && dist[curr] + e.weight < dist[e.to]) {",
      "                dist[e.to] = dist[curr] + e.weight;",
      "                pq.push({dist[e.to], e.to});",
      "            }",
      "        }",
      "    }",
      "    ",
      "    return dist;  // Return vector of shortest distances",
      "}",
    }),
  }),

  -- lca binary lifting
  s("lca_binary_lifting", {
    t({
      "/**",
      " * LCA using Binary Lifting",
      " * Build: O(N log N), Query: O(log N)",
      " * ",
      " * Usage:",
      " *   LCABinaryLifting lca(n);  // n is number of nodes",
      " *   lca.add_edge(u, v);       // add edges",
      " *   lca.build(root);          // build with root",
      " *   int ancestor = lca.get_lca(u, v);  // query LCA of u and v",
      " */",
      "class LCABinaryLifting {",
      "private:",
      "    int n, l;",
      "    vector<vector<int>> adj;",
      "    vector<vector<int>> up;  // up[v][j] is 2^j-th ancestor of v",
      "    vector<int> depth;",
      "",
      "    void dfs(int v, int p) {",
      "        up[v][0] = p;",
      "        for (int j = 1; j < l; j++) {",
      "            if (up[v][j-1] != -1) {",
      "                up[v][j] = up[up[v][j-1]][j-1];",
      "            }",
      "        }",
      "        for (int u : adj[v]) {",
      "            if (u != p) {",
      "                depth[u] = depth[v] + 1;",
      "                dfs(u, v);",
      "            }",
      "        }",
      "    }",
      "",
      "public:",
      "    LCABinaryLifting(int size) : n(size) {",
      "        l = ceil(log2(n)) + 1;",
      "        adj.resize(n);",
      "        up.assign(n, vector<int>(l, -1));",
      "        depth.resize(n);",
      "    }",
      "",
      "    void add_edge(int u, int v) {",
      "        adj[u].push_back(v);",
      "        adj[v].push_back(u);",
      "    }",
      "",
      "    void build(int root = 0) {",
      "        depth[root] = 0;",
      "        dfs(root, -1);",
      "    }",
      "",
      "    int get_lca(int u, int v) {",
      "        if (depth[u] < depth[v]) swap(u, v);",
      "        ",
      "        // Get same depth",
      "        int diff = depth[u] - depth[v];",
      "        for (int j = 0; j < l; j++) {",
      "            if (diff & (1 << j)) {",
      "                u = up[u][j];",
      "            }",
      "        }",
      "        ",
      "        if (u == v) return u;",
      "        ",
      "        // Binary lift to LCA",
      "        for (int j = l-1; j >= 0; j--) {",
      "            if (up[u][j] != up[v][j]) {",
      "                u = up[u][j];",
      "                v = up[v][j];",
      "            }",
      "        }",
      "        ",
      "        return up[u][0];",
      "    }",
      "};",
    }),
  }),

  -- lca_tarjan
  s("lca_tarjan", {
    t({
      "/**",
      " * LCA using Tarjan's Offline Algorithm",
      " * Time Complexity: O(N + Q) where Q is number of queries",
      " * ",
      " * Usage:",
      " *   LCATarjan lca(n);",
      " *   lca.add_edge(u, v);",
      " *   lca.add_query(u, v);",
      " *   auto answers = lca.solve(root);",
      " */",
      "class LCATarjan {",
      "private:",
      "    int n;",
      "    vector<vector<int>> adj;",
      "    vector<vector<pair<int,int>>> queries;  // queries[v] stores {u, query_id}",
      "    vector<int> parent, rank;",
      "    vector<bool> visited;",
      "    vector<int> answer;",
      "",
      "    int find_set(int v) {",
      "        if (v == parent[v]) return v;",
      "        return parent[v] = find_set(parent[v]);",
      "    }",
      "",
      "    void union_sets(int a, int b) {",
      "        a = find_set(a);",
      "        b = find_set(b);",
      "        if (a != b) {",
      "            if (rank[a] < rank[b]) swap(a, b);",
      "            parent[b] = a;",
      "            if (rank[a] == rank[b]) rank[a]++;",
      "        }",
      "    }",
      "",
      "    void dfs(int v) {",
      "        visited[v] = true;",
      "        for (int u : adj[v]) {",
      "            if (!visited[u]) {",
      "                dfs(u);",
      "                union_sets(v, u);",
      "            }",
      "        }",
      "        for (auto [u, idx] : queries[v]) {",
      "            if (visited[u]) {",
      "                answer[idx] = find_set(u);",
      "            }",
      "        }",
      "    }",
      "",
      "public:",
      "    LCATarjan(int size) : n(size) {",
      "        adj.resize(n);",
      "        queries.resize(n);",
      "        parent.resize(n);",
      "        rank.assign(n, 0);",
      "        visited.assign(n, false);",
      "        for (int i = 0; i < n; i++) parent[i] = i;",
      "    }",
      "",
      "    void add_edge(int u, int v) {",
      "        adj[u].push_back(v);",
      "        adj[v].push_back(u);",
      "    }",
      "",
      "    void add_query(int u, int v) {",
      "        queries[u].push_back({v, answer.size()});",
      "        queries[v].push_back({u, answer.size()});",
      "        answer.push_back(-1);",
      "    }",
      "",
      "    vector<int> solve(int root = 0) {",
      "        dfs(root);",
      "        return answer;",
      "    }",
      "};",
    }),
  }),

  -- lca_euler_tour
  s("lca_euler_tour", {
    t({
      "/**",
      " * LCA using Euler Tour + RMQ",
      " * Build: O(N log N), Query: O(1)",
      " * ",
      " * Usage:",
      " *   LCAEulerTour lca(n);",
      " *   lca.add_edge(u, v);",
      " *   lca.build(root);",
      " *   int ancestor = lca.get_lca(u, v);",
      " */",
      "class LCAEulerTour {",
      "private:",
      "    int n;",
      "    vector<vector<int>> adj;",
      "    vector<int> euler, first, depth;",
      "    vector<vector<int>> st;  // Sparse table for RMQ",
      "    ",
      "    void dfs(int v, int p, int d) {",
      "        first[v] = euler.size();",
      "        euler.push_back(v);",
      "        depth[v] = d;",
      "        ",
      "        for (int u : adj[v]) {",
      "            if (u != p) {",
      "                dfs(u, v, d + 1);",
      "                euler.push_back(v);",
      "            }",
      "        }",
      "    }",
      "    ",
      "    void build_sparse_table() {",
      "        int m = euler.size();",
      "        int k = ceil(log2(m)) + 1;",
      "        st.assign(m, vector<int>(k));",
      "        ",
      "        for (int i = 0; i < m; i++) {",
      "            st[i][0] = euler[i];",
      "        }",
      "        ",
      "        for (int j = 1; j < k; j++) {",
      "            for (int i = 0; i + (1 << j) <= m; i++) {",
      "                int left = st[i][j-1];",
      "                int right = st[i + (1 << (j-1))][j-1];",
      "                st[i][j] = depth[left] < depth[right] ? left : right;",
      "            }",
      "        }",
      "    }",
      "    ",
      "    int rmq(int l, int r) {",
      "        int j = 31 - __builtin_clz(r - l + 1);",
      "        int left = st[l][j];",
      "        int right = st[r - (1 << j) + 1][j];",
      "        return depth[left] < depth[right] ? left : right;",
      "    }",
      "",
      "public:",
      "    LCAEulerTour(int size) : n(size) {",
      "        adj.resize(n);",
      "        first.resize(n);",
      "        depth.resize(n);",
      "    }",
      "",
      "    void add_edge(int u, int v) {",
      "        adj[u].push_back(v);",
      "        adj[v].push_back(u);",
      "    }",
      "",
      "    void build(int root = 0) {",
      "        euler.clear();",
      "        dfs(root, -1, 0);",
      "        build_sparse_table();",
      "    }",
      "",
      "    int get_lca(int u, int v) {",
      "        int left = first[u], right = first[v];",
      "        if (left > right) swap(left, right);",
      "        return rmq(left, right);",
      "    }",
      "};",
    }),
  }),

  -- Linear sieve
  s("linear_sieve", {
    t({
      "/**",
      " * Linear Prime Sieve (Euler Sieve)",
      " * Generates all primes up to n and marks composite numbers with their smallest prime factor",
      " * @param n: int - Upper bound of range [1, n]",
      " * @return: tuple<vector<bool>, vector<int>, vector<int>>",
      " *          - is_prime: Boolean array marking prime numbers",
      " *          - primes: Vector containing all prime numbers up to n",
      " *          - min_factor: Smallest prime factor for each number",
      " * Time Complexity: O(n)",
      " * Space Complexity: O(n)",
      " * Note: This is the fastest known prime sieve algorithm",
      " */",
      "tuple<vector<bool>, vector<int>, vector<int>> prime_sieve(int n) {",
      "    vector<bool> is_prime(n + 1, true);",
      "    vector<int> primes;",
      "    vector<int> min_factor(n + 1, 0);  // Smallest prime factor",
      "",
      "    is_prime[0] = is_prime[1] = false;",
      "",
      "    for (int i = 2; i <= n; ++i) {",
      "        if (is_prime[i]) {",
      "            primes.push_back(i);",
      "            min_factor[i] = i;  // Prime number's smallest factor is itself",
      "        }",
      "",
      "        // Mark multiples of prime numbers as composite",
      "        for (int j = 0; j < (int)primes.size() && i * primes[j] <= n; ++j) {",
      "            int curr = i * primes[j];",
      "            is_prime[curr] = false;",
      "            min_factor[curr] = primes[j];  // Store smallest prime factor",
      "",
      "            if (i % primes[j] == 0) break;  // Optimization: break at smallest prime factor",
      "        }",
      "    }",
      "",
      "    return {is_prime, primes, min_factor};",
      "}",
      "",
      "/**",
      " * Prime Factorization using precomputed smallest prime factors",
      " * @param x: int - Number to factorize",
      " * @param min_factor: vector<int>& - Precomputed smallest prime factors",
      " * @return: vector<pair<int, int>> - Prime factors and their exponents",
      " * Time Complexity: O(log x)",
      " */",
      "vector<pair<int, int>> factorize(int x, const vector<int>& min_factor) {",
      "    vector<pair<int, int>> factors;",
      "    ",
      "    while (x > 1) {",
      "        int prime = min_factor[x];",
      "        int count = 0;",
      "        ",
      "        while (x % prime == 0) {",
      "            x /= prime;",
      "            count++;",
      "        }",
      "        ",
      "        factors.emplace_back(prime, count);",
      "    }",
      "    ",
      "    return factors;",
      "}",
    }),
  }),

  -- quick power
  s("quick_power", {
    t({
      "/**",
      " * Quick Power (Binary Exponentiation)",
      " * Calculates base^exp efficiently",
      " * @template T - Type of base and result (typically long long)",
      " * @param base: T - Base number",
      " * @param exp: long long - Exponent (must be non-negative)",
      " * @return: T - Result of base^exp",
      " * Time Complexity: O(log exp)",
      " * Space Complexity: O(1)",
      " */",
      "template <typename T>",
      "T qpow(T base, long long exp) {",
      "    T res = 1;",
      "    while (exp > 0) {",
      "        if (exp & 1) res = res * base;",
      "        base = base * base;",
      "        exp >>= 1;",
      "    }",
      "    return res;",
      "}",
      "",
      "/**",
      " * Modular Quick Power",
      " * Calculates (base^exp) % mod efficiently",
      " * @template T - Type of base and result (typically long long)",
      " * @param base: T - Base number",
      " * @param exp: long long - Exponent (must be non-negative)",
      " * @param mod: T - Modulus (must be positive)",
      " * @return: T - Result of (base^exp) % mod",
      " * Time Complexity: O(log exp)",
      " * Space Complexity: O(1)",
      " * Note: Results are always non-negative and less than mod",
      " */",
      "template <typename T>",
      "T qpow(T base, long long exp, T mod) {",
      "    T res = 1;",
      "    base %= mod;",
      "    while (exp > 0) {",
      "        if (exp & 1) res = (__int128_t)res * base % mod;  // Use __int128_t to prevent overflow",
      "        base = (__int128_t)base * base % mod;",
      "        exp >>= 1;",
      "    }",
      "    return res;",
      "}",
    }),
  }),

  -- 1d prefix sum
  s("1dpsum", {
    t({
      "/**",
      " * One-dimensional Prefix Sum Array",
      " * @template T - Type of array elements (typically int or long long)",
      " */",
      "template <typename T>",
      "class PrefixSum {",
      "private:",
      "    vector<T> sum;  // Prefix sum array",
      "",
      "public:",
      "    /**",
      "     * Builds prefix sum array from input array",
      "     * @param arr: const vector<T>& - Input array",
      "     * Time Complexity: O(n)",
      "     * Space Complexity: O(n)",
      "     */",
      "    PrefixSum(const vector<T>& arr) {",
      "        int n = arr.size();",
      "        sum.resize(n + 1);  // One extra space for empty prefix",
      "        sum[0] = 0;  // Empty prefix",
      "        ",
      "        for (int i = 0; i < n; ++i) {",
      "            sum[i + 1] = sum[i] + arr[i];",
      "        }",
      "    }",
      "",
      "    /**",
      "     * Queries sum of range [left, right] (inclusive)",
      "     * @param left: int - Left boundary (0-based)",
      "     * @param right: int - Right boundary (0-based)",
      "     * @return: T - Sum of elements in range [left, right]",
      "     * Time Complexity: O(1)",
      "     * Precondition: 0 <= left <= right < n",
      "     */",
      "    T query(int left, int right) const {",
      "        return sum[right + 1] - sum[left];",
      "    }",
      "",
      "    /**",
      "     * Returns prefix sum up to index i (inclusive)",
      "     * @param i: int - Right boundary (0-based)",
      "     * @return: T - Sum of elements in range [0, i]",
      "     * Time Complexity: O(1)",
      "     * Precondition: 0 <= i < n",
      "     */",
      "    T prefix(int i) const {",
      "        return sum[i + 1];",
      "    }",
      "",
      "    /**",
      "     * Returns size of original array",
      "     * @return: int - Size of original array",
      "     */",
      "    int size() const {",
      "        return sum.size() - 1;",
      "    }",
      "};",
    }),
  }),

  -- 2D Prefix sum
  s("2dpsum", {
    t({
      "/**",
      " * Two-dimensional Prefix Sum Array",
      " * @template T - Type of array elements (typically int or long long)",
      " */",
      "template <typename T>",
      "class PrefixSum2D {",
      "private:",
      "    vector<vector<T>> sum;  // 2D prefix sum array",
      "    int n, m;               // Dimensions of the original array",
      "",
      "public:",
      "    /**",
      "     * Builds 2D prefix sum array from input matrix",
      "     * @param matrix: const vector<vector<T>>& - Input 2D array",
      "     * Time Complexity: O(n*m)",
      "     * Space Complexity: O(n*m)",
      "     */",
      "    PrefixSum2D(const vector<vector<T>>& matrix) {",
      "        n = matrix.size();",
      "        m = n ? matrix[0].size() : 0;",
      "        sum.assign(n + 1, vector<T>(m + 1, 0));",
      "",
      "        // Build 2D prefix sum array",
      "        for (int i = 0; i < n; ++i) {",
      "            for (int j = 0; j < m; ++j) {",
      "                sum[i + 1][j + 1] = matrix[i][j] + ",
      "                                    sum[i + 1][j] + ",
      "                                    sum[i][j + 1] - ",
      "                                    sum[i][j];",
      "            }",
      "        }",
      "    }",
      "",
      "    /**",
      "     * Queries sum of rectangle [(x1,y1), (x2,y2)] (inclusive)",
      "     * @param x1, y1: int - Top-left coordinates (0-based)",
      "     * @param x2, y2: int - Bottom-right coordinates (0-based)",
      "     * @return: T - Sum of elements in the rectangle",
      "     * Time Complexity: O(1)",
      "     * Precondition: 0 <= x1 <= x2 < n, 0 <= y1 <= y2 < m",
      "     */",
      "    T query(int x1, int y1, int x2, int y2) const {",
      "        return sum[x2 + 1][y2 + 1] - ",
      "               sum[x2 + 1][y1] - ",
      "               sum[x1][y2 + 1] + ",
      "               sum[x1][y1];",
      "    }",
      "",
      "    /**",
      "     * Returns prefix sum up to (x,y) (inclusive)",
      "     * @param x, y: int - Bottom-right coordinates (0-based)",
      "     * @return: T - Sum of elements in rectangle [(0,0), (x,y)]",
      "     * Time Complexity: O(1)",
      "     * Precondition: 0 <= x < n, 0 <= y < m",
      "     */",
      "    T prefix(int x, int y) const {",
      "        return sum[x + 1][y + 1];",
      "    }",
      "",
      "    /**",
      "     * Returns dimensions of original matrix",
      "     * @return: pair<int,int> - {rows, columns}",
      "     */",
      "    pair<int, int> size() const {",
      "        return {n, m};",
      "    }",
      "",
      "    /**",
      "     * Gets original value at position (x,y)",
      "     * @param x, y: int - Coordinates (0-based)",
      "     * @return: T - Original value at (x,y)",
      "     * Time Complexity: O(1)",
      "     * Precondition: 0 <= x < n, 0 <= y < m",
      "     */",
      "    T get(int x, int y) const {",
      "        return query(x, y, x, y);",
      "    }",
      "};",
    }),
  }),

  -- 1d difference
  s("1d_diff", {
    t({
      "/**",
      " * One-dimensional Difference Array",
      " * Supports range updates and point queries in O(1) time",
      " * @template T - Type of array elements (typically int or long long)",
      " */",
      "template <typename T>",
      "class DifferenceArray {",
      "private:",
      "    vector<T> diff;  // Difference array",
      "    vector<T> original;  // Original array (maintained for queries)",
      "    bool rebuilt;    // Flag to track if original array is up to date",
      "",
      "    /**",
      "     * Rebuilds original array from difference array",
      "     * Time Complexity: O(n)",
      "     */",
      "    void rebuild() {",
      "        if (rebuilt) return;",
      "        int n = diff.size();",
      "        original[0] = diff[0];",
      "        for (int i = 1; i < n; ++i) {",
      "            original[i] = original[i-1] + diff[i];",
      "        }",
      "        rebuilt = true;",
      "    }",
      "",
      "public:",
      "    /**",
      "     * Constructor: initializes difference array from input array",
      "     * @param arr: const vector<T>& - Input array",
      "     * Time Complexity: O(n)",
      "     */",
      "    DifferenceArray(const vector<T>& arr) {",
      "        int n = arr.size();",
      "        diff.resize(n);",
      "        original = arr;",
      "        ",
      "        // Build difference array",
      "        diff[0] = arr[0];",
      "        for (int i = 1; i < n; ++i) {",
      "            diff[i] = arr[i] - arr[i-1];",
      "        }",
      "        rebuilt = true;",
      "    }",
      "",
      "    /**",
      "     * Adds value to range [left, right]",
      "     * @param left: int - Left boundary (inclusive)",
      "     * @param right: int - Right boundary (inclusive)",
      "     * @param value: T - Value to add",
      "     * Time Complexity: O(1)",
      "     */",
      "    void add_range(int left, int right, T value) {",
      "        diff[left] += value;",
      "        if (right + 1 < diff.size()) {",
      "            diff[right + 1] -= value;",
      "        }",
      "        rebuilt = false;",
      "    }",
      "",
      "    /**",
      "     * Gets value at specific position",
      "     * @param pos: int - Position to query",
      "     * @return: T - Value at position",
      "     * Time Complexity: O(n) for first query, O(1) for subsequent queries",
      "     */",
      "    T get(int pos) {",
      "        rebuild();",
      "        return original[pos];",
      "    }",
      "",
      "    /**",
      "     * Gets the entire array after all updates",
      "     * @return: vector<T> - Current state of array",
      "     * Time Complexity: O(n)",
      "     */",
      "    vector<T> get_array() {",
      "        rebuild();",
      "        return original;",
      "    }",
      "",
      "    /**",
      "     * Gets size of the array",
      "     * @return: int - Size of array",
      "     */",
      "    int size() const {",
      "        return diff.size();",
      "    }",
      "};",
    }),
  }),

  -- 2D difference array

  s("2d_diff", {
    t({
      "/**",
      " * Two-dimensional Difference Array",
      " * Supports rectangle updates and point queries",
      " * @template T - Type of array elements (typically int or long long)",
      " */",
      "template <typename T>",
      "class DifferenceArray2D {",
      "private:",
      "    vector<vector<T>> diff;      // 2D difference array",
      "    vector<vector<T>> original;  // Original matrix",
      "    int n, m;                    // Dimensions of the matrix",
      "    bool rebuilt;                // Flag to track if original matrix is up to date",
      "",
      "    /**",
      "     * Rebuilds original matrix from difference array",
      "     * Time Complexity: O(n*m)",
      "     */",
      "    void rebuild() {",
      "        if (rebuilt) return;",
      "        ",
      "        // First row prefix sum",
      "        original[0][0] = diff[0][0];",
      "        for (int j = 1; j < m; ++j) {",
      "            original[0][j] = original[0][j-1] + diff[0][j];",
      "        }",
      "        ",
      "        // First column prefix sum",
      "        for (int i = 1; i < n; ++i) {",
      "            original[i][0] = original[i-1][0] + diff[i][0];",
      "        }",
      "        ",
      "        // Rest of the matrix",
      "        for (int i = 1; i < n; ++i) {",
      "            for (int j = 1; j < m; ++j) {",
      "                original[i][j] = original[i-1][j] + original[i][j-1] - ",
      "                                original[i-1][j-1] + diff[i][j];",
      "            }",
      "        }",
      "        ",
      "        rebuilt = true;",
      "    }",
      "",
      "public:",
      "    /**",
      "     * Constructor: initializes 2D difference array from input matrix",
      "     * @param matrix: const vector<vector<T>>& - Input matrix",
      "     * Time Complexity: O(n*m)",
      "     */",
      "    DifferenceArray2D(const vector<vector<T>>& matrix) {",
      "        n = matrix.size();",
      "        m = n ? matrix[0].size() : 0;",
      "        diff.assign(n, vector<T>(m));",
      "        original = matrix;",
      "        ",
      "        // Build difference array",
      "        diff[0][0] = matrix[0][0];",
      "        ",
      "        // First row",
      "        for (int j = 1; j < m; ++j) {",
      "            diff[0][j] = matrix[0][j] - matrix[0][j-1];",
      "        }",
      "        ",
      "        // First column",
      "        for (int i = 1; i < n; ++i) {",
      "            diff[i][0] = matrix[i][0] - matrix[i-1][0];",
      "        }",
      "        ",
      "        // Rest of the matrix",
      "        for (int i = 1; i < n; ++i) {",
      "            for (int j = 1; j < m; ++j) {",
      "                diff[i][j] = matrix[i][j] - matrix[i][j-1] - ",
      "                            matrix[i-1][j] + matrix[i-1][j-1];",
      "            }",
      "        }",
      "        ",
      "        rebuilt = true;",
      "    }",
      "",
      "    /**",
      "     * Adds value to rectangle [(x1,y1), (x2,y2)]",
      "     * @param x1, y1: int - Top-left coordinates",
      "     * @param x2, y2: int - Bottom-right coordinates",
      "     * @param value: T - Value to add",
      "     * Time Complexity: O(1)",
      "     */",
      "    void add_rectangle(int x1, int y1, int x2, int y2, T value) {",
      "        diff[x1][y1] += value;",
      "        if (y2 + 1 < m) diff[x1][y2 + 1] -= value;",
      "        if (x2 + 1 < n) diff[x2 + 1][y1] -= value;",
      "        if (x2 + 1 < n && y2 + 1 < m) diff[x2 + 1][y2 + 1] += value;",
      "        rebuilt = false;",
      "    }",
      "",
      "    /**",
      "     * Gets value at specific position",
      "     * @param x, y: int - Coordinates",
      "     * @return: T - Value at position",
      "     * Time Complexity: O(n*m) for first query, O(1) for subsequent queries",
      "     */",
      "    T get(int x, int y) {",
      "        rebuild();",
      "        return original[x][y];",
      "    }",
      "",
      "    /**",
      "     * Gets the entire matrix after all updates",
      "     * @return: vector<vector<T>> - Current state of matrix",
      "     * Time Complexity: O(n*m)",
      "     */",
      "    vector<vector<T>> get_matrix() {",
      "        rebuild();",
      "        return original;",
      "    }",
      "",
      "    /**",
      "     * Gets dimensions of the matrix",
      "     * @return: pair<int,int> - {rows, columns}",
      "     */",
      "    pair<int, int> size() const {",
      "        return {n, m};",
      "    }",
      "};",
    }),
  }),

  -- kmp
  s("kmp", {
    t({
      "/**",
      " * KMP (Knuth-Morris-Pratt) String Matching Algorithm",
      " * Build failure function and perform string matching",
      " * @template T - Type of elements (typically char for strings)",
      " */",
      "template <typename T>",
      "class KMP {",
      "private:",
      "    vector<T> pattern;     // Pattern to search for",
      "    vector<int> fail;      // Failure function array",
      "",
      "    /**",
      "     * Builds the failure function array",
      "     * fail[i] = length of longest proper prefix which is also suffix of pattern[0...i]",
      "     * Time Complexity: O(|pattern|)",
      "     */",
      "    void build_failure_function() {",
      "        int n = pattern.size();",
      "        fail.assign(n, 0);",
      "        ",
      "        for (int i = 1, j = 0; i < n; ++i) {",
      "            while (j > 0 && pattern[i] != pattern[j]) {",
      "                j = fail[j - 1];",
      "            }",
      "            if (pattern[i] == pattern[j]) {",
      "                ++j;",
      "            }",
      "            fail[i] = j;",
      "        }",
      "    }",
      "",
      "public:",
      "    /**",
      "     * Constructor: initializes KMP with a pattern",
      "     * @param p: const vector<T>& - Pattern to search for",
      "     * Time Complexity: O(|pattern|)",
      "     */",
      "    KMP(const vector<T>& p) : pattern(p) {",
      "        build_failure_function();",
      "    }",
      "",
      "    /**",
      "     * Constructor: initializes KMP with a string pattern",
      "     * @param p: const string& - Pattern string",
      "     * Time Complexity: O(|pattern|)",
      "     */",
      "    KMP(const string& p) {",
      "        pattern = vector<T>(p.begin(), p.end());",
      "        build_failure_function();",
      "    }",
      "",
      "    /**",
      "     * Finds all occurrences of pattern in text",
      "     * @param text: const vector<T>& - Text to search in",
      "     * @return: vector<int> - Starting positions of all matches",
      "     * Time Complexity: O(|text|)",
      "     */",
      "    vector<int> find_all(const vector<T>& text) const {",
      "        vector<int> positions;",
      "        int m = pattern.size();",
      "        int n = text.size();",
      "        ",
      "        for (int i = 0, j = 0; i < n; ++i) {",
      "            while (j > 0 && text[i] != pattern[j]) {",
      "                j = fail[j - 1];",
      "            }",
      "            if (text[i] == pattern[j]) {",
      "                ++j;",
      "            }",
      "            if (j == m) {",
      "                positions.push_back(i - m + 1);",
      "                j = fail[j - 1];",
      "            }",
      "        }",
      "        ",
      "        return positions;",
      "    }",
      "",
      "    /**",
      "     * Finds all occurrences of pattern in text string",
      "     * @param text: const string& - Text string to search in",
      "     * @return: vector<int> - Starting positions of all matches",
      "     * Time Complexity: O(|text|)",
      "     */",
      "    vector<int> find_all(const string& text) const {",
      "        return find_all(vector<T>(text.begin(), text.end()));",
      "    }",
      "",
      "    /**",
      "     * Gets the failure function array",
      "     * @return: const vector<int>& - Reference to failure function array",
      "     */",
      "    const vector<int>& get_failure_function() const {",
      "        return fail;",
      "    }",
      "",
      "    /**",
      "     * Gets the pattern length",
      "     * @return: int - Length of the pattern",
      "     */",
      "    int pattern_length() const {",
      "        return pattern.size();",
      "    }",
      "};",
    }),
  }),

  -- ac automaton
  s("ac_automaton", {
    t({
      "/**",
      " * Aho-Corasick Automaton implementation",
      " * Used for multiple pattern string matching",
      " * Combines trie with KMP-like failure links",
      " */",
      "class ACAutomaton {",
      "private:",
      "    static const int CHARSET_SIZE = 26;  // Assuming lowercase letters only",
      "    ",
      "    struct Node {",
      "        vector<int> next;      // Transitions to child nodes",
      "        int fail;              // Failure link",
      "        vector<int> output;    // Pattern indices ending at this node",
      "        bool is_end;           // Whether this node is end of a pattern",
      "        ",
      "        Node() : next(CHARSET_SIZE, -1), fail(0), is_end(false) {}",
      "    };",
      "    ",
      "    vector<Node> trie;  // The automaton nodes",
      "    int root;           // Root node index",
      "    ",
      "    /**",
      "     * Converts character to index",
      "     * @param c: char - Input character",
      "     * @return: int - Index in transition array",
      "     */",
      "    int char_to_index(char c) const {",
      "        return c - 'a';  // Assuming lowercase letters",
      "    }",
      "",
      "public:",
      "    /**",
      "     * Constructor: initializes empty automaton",
      "     * Time Complexity: O(1)",
      "     */",
      "    ACAutomaton() {",
      "        trie.push_back(Node());  // Create root node",
      "        root = 0;",
      "    }",
      "    ",
      "    /**",
      "     * Inserts a pattern into the automaton",
      "     * @param pattern: const string& - Pattern to insert",
      "     * @param pattern_index: int - Index of the pattern",
      "     * Time Complexity: O(|pattern|)",
      "     */",
      "    void insert(const string& pattern, int pattern_index) {",
      "        int curr = root;",
      "        ",
      "        for (char c : pattern) {",
      "            int idx = char_to_index(c);",
      "            if (trie[curr].next[idx] == -1) {",
      "                trie[curr].next[idx] = trie.size();",
      "                trie.push_back(Node());",
      "            }",
      "            curr = trie[curr].next[idx];",
      "        }",
      "        ",
      "        trie[curr].is_end = true;",
      "        trie[curr].output.push_back(pattern_index);",
      "    }",
      "    ",
      "    /**",
      "     * Builds failure links for the automaton",
      "     * Must be called after all patterns are inserted",
      "     * Time Complexity: O(sum of pattern lengths)",
      "     */",
      "    void build() {",
      "        queue<int> q;",
      "        ",
      "        // Initialize failure links for depth 1 nodes",
      "        for (int i = 0; i < CHARSET_SIZE; ++i) {",
      "            if (trie[root].next[i] != -1) {",
      "                trie[trie[root].next[i]].fail = root;",
      "                q.push(trie[root].next[i]);",
      "            } else {",
      "                trie[root].next[i] = root;",
      "            }",
      "        }",
      "        ",
      "        // BFS to build failure links",
      "        while (!q.empty()) {",
      "            int curr = q.front();",
      "            q.pop();",
      "            ",
      "            // Copy output function from failure link",
      "            if (trie[trie[curr].fail].is_end) {",
      "                trie[curr].output.insert(trie[curr].output.end(),",
      "                    trie[trie[curr].fail].output.begin(),",
      "                    trie[trie[curr].fail].output.end());",
      "            }",
      "            ",
      "            // Process all possible transitions",
      "            for (int i = 0; i < CHARSET_SIZE; ++i) {",
      "                if (trie[curr].next[i] != -1) {",
      "                    int next = trie[curr].next[i];",
      "                    int f = trie[curr].fail;",
      "                    ",
      "                    // Find correct failure link",
      "                    while (f != root && trie[f].next[i] == -1) {",
      "                        f = trie[f].fail;",
      "                    }",
      "                    ",
      "                    trie[next].fail = trie[f].next[i];",
      "                    q.push(next);",
      "                }",
      "            }",
      "        }",
      "    }",
      "    ",
      "    /**",
      "     * Searches for all pattern occurrences in text",
      "     * @param text: const string& - Text to search in",
      "     * @return: vector<pair<int,int>> - Vector of {pattern_index, position} pairs",
      "     * Time Complexity: O(|text| + number of matches)",
      "     */",
      "    vector<pair<int,int>> search(const string& text) {",
      "        vector<pair<int,int>> results;",
      "        int curr = root;",
      "        ",
      "        for (int i = 0; i < text.length(); ++i) {",
      "            int idx = char_to_index(text[i]);",
      "            ",
      "            // Follow failure links until matching transition is found",
      "            while (curr != root && trie[curr].next[idx] == -1) {",
      "                curr = trie[curr].fail;",
      "            }",
      "            ",
      "            curr = trie[curr].next[idx];",
      "            ",
      "            // Report all matches at current node",
      "            if (trie[curr].is_end) {",
      "                for (int pattern_idx : trie[curr].output) {",
      "                    results.emplace_back(pattern_idx, i);",
      "                }",
      "            }",
      "        }",
      "        ",
      "        return results;",
      "    }",
      "};",
    }),
  }),

  -- maximum flow algorithms
  s("dinic", {
    t({
      "/**",
      " * Dinic's Maximum Flow Algorithm",
      " * Time Complexity: O(V^2E) general, O(E√V) for bipartite matching",
      " * ",
      " * Usage:",
      " *   Dinic flow(n);  // n is number of nodes (0-based)",
      " *   flow.add_edge(from, to, capacity);",
      " *   long long max_flow = flow.max_flow(source, sink);",
      " */",
      "class Dinic {",
      "private:",
      "    struct Edge {",
      "        int to, rev;",
      "        long long cap, flow;",
      "        Edge(int t, int r, long long c) : to(t), rev(r), cap(c), flow(0) {}",
      "    };",
      "",
      "    int n;",
      "    vector<vector<Edge>> adj;",
      "    vector<int> level, ptr;",
      "",
      "    bool bfs(int s, int t) {",
      "        level.assign(n, -1);",
      "        level[s] = 0;",
      "        queue<int> q;",
      "        q.push(s);",
      "",
      "        while (!q.empty() && level[t] == -1) {",
      "            int v = q.front();",
      "            q.pop();",
      "",
      "            for (Edge& e : adj[v]) {",
      "                if (level[e.to] == -1 && e.cap - e.flow > 0) {",
      "                    level[e.to] = level[v] + 1;",
      "                    q.push(e.to);",
      "                }",
      "            }",
      "        }",
      "        return level[t] != -1;",
      "    }",
      "",
      "    long long dfs(int v, int t, long long pushed) {",
      "        if (v == t || pushed == 0) return pushed;",
      "",
      "        for (int& i = ptr[v]; i < adj[v].size(); i++) {",
      "            Edge& e = adj[v][i];",
      "            ",
      "            if (level[e.to] != level[v] + 1 || e.cap - e.flow == 0) continue;",
      "",
      "            long long flow = dfs(e.to, t, min(pushed, e.cap - e.flow));",
      "            if (flow == 0) continue;",
      "",
      "            e.flow += flow;",
      "            adj[e.to][e.rev].flow -= flow;",
      "            return flow;",
      "        }",
      "        return 0;",
      "    }",
      "",
      "public:",
      "    Dinic(int vertices) : n(vertices) {",
      "        adj.resize(n);",
      "        level.resize(n);",
      "        ptr.resize(n);",
      "    }",
      "",
      "    void add_edge(int from, int to, long long capacity) {",
      "        adj[from].push_back(Edge(to, adj[to].size(), capacity));",
      "        adj[to].push_back(Edge(from, adj[from].size()-1, 0));  // Reverse edge",
      "    }",
      "",
      "    long long max_flow(int s, int t) {",
      "        long long flow = 0;",
      "        while (bfs(s, t)) {",
      "            ptr.assign(n, 0);",
      "            while (long long pushed = dfs(s, t, LLONG_MAX)) {",
      "                flow += pushed;",
      "            }",
      "        }",
      "        return flow;",
      "    }",
      "",
      "    // Get the final flow through edge (useful for flow decomposition)",
      "    long long get_flow(int edge_idx, int from) {",
      "        return adj[from][edge_idx].flow;",
      "    }",
      "};",
    }),
  }),

  s("isap", {
    t({
      "/**",
      " * ISAP (Improved Shortest Augmenting Path) Algorithm",
      " * Time Complexity: O(V^2E)",
      " * Better constant factor than Dinic's for dense graphs",
      " */",
      "class ISAP {",
      "private:",
      "    struct Edge {",
      "        int to, rev;",
      "        long long cap, flow;",
      "        Edge(int t, int r, long long c) : to(t), rev(r), cap(c), flow(0) {}",
      "    };",
      "",
      "    int n;",
      "    vector<vector<Edge>> adj;",
      "    vector<int> height, gap, cur;",
      "",
      "    long long dfs(int v, int t, long long flow) {",
      "        if (v == t) return flow;",
      "",
      "        for (int& i = cur[v]; i < adj[v].size(); i++) {",
      "            Edge& e = adj[v][i];",
      "            if (height[v] == height[e.to] + 1 && e.cap - e.flow > 0) {",
      "                long long pushed = dfs(e.to, t, min(flow, e.cap - e.flow));",
      "                if (pushed > 0) {",
      "                    e.flow += pushed;",
      "                    adj[e.to][e.rev].flow -= pushed;",
      "                    return pushed;",
      "                }",
      "            }",
      "        }",
      "        return 0;",
      "    }",
      "",
      "public:",
      "    ISAP(int vertices) : n(vertices) {",
      "        adj.resize(n);",
      "        height.resize(n);",
      "        gap.resize(n);",
      "        cur.resize(n);",
      "    }",
      "",
      "    void add_edge(int from, int to, long long capacity) {",
      "        adj[from].push_back(Edge(to, adj[to].size(), capacity));",
      "        adj[to].push_back(Edge(from, adj[from].size()-1, 0));",
      "    }",
      "",
      "    long long max_flow(int s, int t) {",
      "        long long flow = 0;",
      "        height.assign(n, 0);",
      "        gap.assign(n, 0);",
      "        cur.assign(n, 0);",
      "",
      "        height[s] = n;",
      "        gap[0] = n-1;",
      "        gap[n] = 1;",
      "",
      "        while (height[s] < n) {",
      "            long long pushed = dfs(s, t, LLONG_MAX);",
      "            if (pushed == 0) {",
      "                int minh = n;",
      "                for (Edge& e : adj[s]) {",
      "                    if (e.cap - e.flow > 0) {",
      "                        minh = min(minh, height[e.to]);",
      "                    }",
      "                }",
      "                if (--gap[height[s]] == 0) break;",
      "                height[s] = minh + 1;",
      "                gap[height[s]]++;",
      "                cur[s] = 0;",
      "            } else {",
      "                flow += pushed;",
      "            }",
      "        }",
      "        return flow;",
      "    }",
      "};",
    }),
  }),

  s("push_relabel", {
    t({
      "/**",
      " * Push-Relabel Maximum Flow Algorithm (Highest Label variant)",
      " * Time Complexity: O(V^2√E)",
      " * Good for dense graphs",
      " */",
      "class PushRelabel {",
      "private:",
      "    struct Edge {",
      "        int to;",
      "        long long cap, flow;",
      "        Edge(int t, long long c) : to(t), cap(c), flow(0) {}",
      "    };",
      "",
      "    int n;",
      "    vector<vector<Edge>> adj;",
      "    vector<long long> excess;",
      "    vector<int> height, count;",
      "    vector<bool> active;",
      "    vector<vector<int>> B;  // Buckets for highest label selection",
      "",
      "    void push(Edge& e, int from, int to) {",
      "        long long d = min(excess[from], e.cap - e.flow);",
      "        e.flow += d;",
      "        excess[from] -= d;",
      "        excess[to] += d;",
      "        if (d && excess[to] == d) active[to] = true;",
      "    }",
      "",
      "    void relabel(int v) {",
      "        int minh = 2*n;",
      "        for (Edge& e : adj[v]) {",
      "            if (e.cap - e.flow > 0) {",
      "                minh = min(minh, height[e.to]);",
      "            }",
      "        }",
      "        int h = height[v];",
      "        height[v] = minh + 1;",
      "        count[h]--;",
      "        count[height[v]]++;",
      "    }",
      "",
      "    void discharge(int v) {",
      "        while (excess[v] > 0) {",
      "            if (height[v] == n) {",
      "                return;",
      "            }",
      "            for (Edge& e : adj[v]) {",
      "                if (e.cap - e.flow > 0 && height[v] == height[e.to] + 1) {",
      "                    push(e, v, e.to);",
      "                    if (excess[v] == 0) break;",
      "                }",
      "            }",
      "            if (excess[v] > 0) {",
      "                relabel(v);",
      "            }",
      "        }",
      "        active[v] = false;",
      "    }",
      "",
      "public:",
      "    PushRelabel(int vertices) : n(vertices) {",
      "        adj.resize(n);",
      "        excess.resize(n);",
      "        height.resize(n);",
      "        count.resize(2*n);",
      "        active.resize(n);",
      "        B.resize(2*n);",
      "    }",
      "",
      "    void add_edge(int from, int to, long long capacity) {",
      "        adj[from].push_back(Edge(to, capacity));",
      "        adj[to].push_back(Edge(from, 0));",
      "    }",
      "",
      "    long long max_flow(int s, int t) {",
      "        // Initialize preflow",
      "        height[s] = n;",
      "        excess[s] = LLONG_MAX;",
      "        count[0] = n-1;",
      "        count[n] = 1;",
      "",
      "        for (Edge& e : adj[s]) {",
      "            push(e, s, e.to);",
      "        }",
      "",
      "        // Main loop",
      "        while (true) {",
      "            bool found = false;",
      "            for (int i = 0; i < n; i++) {",
      "                if (i != s && i != t && excess[i] > 0) {",
      "                    discharge(i);",
      "                    found = true;",
      "                }",
      "            }",
      "            if (!found) break;",
      "        }",
      "",
      "        return excess[t];",
      "    }",
      "};",
    }),
  }),
})
